# Block Generation

The logic which is used to generate the rollup chain from L1.

## Glossary

- **Block Inputs**: All information required to generate a full Ethereum block, given the pre-state and previous block. For example, does NOT include a state root for that block's input.
- **Rollup Blockchain**: The rollup blocks generated by performing the rollup's state transition function over all block inputs. For example, DOES include a state root for that block's input.

## Introduction

In the abstract, Optimistic Ethereum--_in fact, **all** rollup constructions_--can be represented as a pure function of the L1 chain:

```
get_rollup_state(current_l1_blockchain) -> current_rollup_state # this applies to ANY rollup!
```

Creating a "good" rollup is all about composing the `get_rollup_state` function as useful abstractions satisfying different DevEx, UX, or architectural goals. This page will cover most of those abstractions chosen for Optimistic Ethereum.

### Motivation 1: EVM Equivalence

Optimistic Ethereum's goal is to resemble Ethereum as closely as possible. In particular, OE nodes' core execution logic should be contained in the EE, which has [as minimal a set of differences from L1][exec-engine-diffs] as L2 can fundamentally allow.

To accomplish this, we define an intermediate transformation from L1 blocks to L2 blocks that are recursively applied against the state, just as L1 Ethereum does. That is, we define a function 

```
get_rollup_blockchain(current_l1_blockchain) -> current_l2_blockchain
```

which outputs a list of L2 blocks, such that 

```
current_rollup_state = apply(l2_block_n, apply(l2_block_n-1,...apply(l2_block_0, l2_genesis)...))
```

where `l2_block_i` is the `i`th element of `current_l2_blockchain`, and `apply()` corresponds to the EVM-equivalent STF implemented by the EE.

### Motivation 2: Input/Execution Separation

In L1 Ethereum, each block contains within it execution results--for example, the new EVM state root. In L2, transaction submission and execution are more separated--state is "finalized" only once the challenge period has elapsed. Furthermore, we would like to minimize calldata, and submitting state roots would be a waste. The rollup should "arrive at the correct state root" as a result of the dispute game, as opposed to one being submitted up front.

So, we define **L2 Block Inputs** as the subset of Ethereum blockdata which does not require EVM-level opcode execution, but which is sufficient to generate a single valid Ethereum block. See the glossary for a precise definition.

With this modification, the rollup function becomes
```
get_rollup_block_inputs(current_l1_blockchain) -> current_l2_block_inputs
```
and the `apply` function now takes care of generating the `stateRoot`, `receiptsRoot`, etc. to generate a full L2 block matching the Ethereum Yellow paper.

### Motivation 3: L1 History Independence

The [Rollup Driver][rollup-driver] is the subcomponent of the node responsible for determining the L2 Block Inputs and making sure the EE correctly applies them. We would like this subcomponent to be stateless (does not require its own persistent DB) and context independent (does not require re-processing all L1 blocks on startup).

So, we require that the rollup can be split into discrete "epochs," 1 for each L1 block,  which accept a constant sized number of L1 blocks leading up to the epoch's L1 block itself, and accesses persistent state only from the L2 EE:

```
get_epoch_rollup_inputs(recent_l1_blocks, previous_epoch_l2_state) -> epoch_rollup_inputs
```

So that `get_rollup_block_inputs` above is the concatenation of `get_epoch_rollup_inputs` for each L1 block since the start of the chain.

### Motivation 4: Censorship-Resistant Sequencing

We would like Optimistic Ethereum to leverage a censorship-resistant sequencing mechanism. In particular:

- A single party (or a group performing consensus), the sequencer, should be able to reliably predict future L2 state, so long as it can fulfill a liveness requirement by submitting some corresponding data to L1 within some time.
- Despite this, the sequencer should not be able to censor user transactions or deposits, which are directly submitted to L1, for an unbounded period of time.

To accomplish this, we introduce two feeds, the Deposit Feed and the Sequencer Feed. These are both pure functions of the `recent_l1_blocks` for the given epoch. Together, and with the L2 state, these feeds can be used to reconstruct the full block inputs.

```
get_epoch_deposits(recent_l1_blocks) -> epoch_deposits
get_epoch_sequence_data(recent_l1_blocks) -> epoch_sequence_data
get_epoch_rollup_inputs(
    epoch_deposits,
    epoch_sequence_data,
    previous_epoch_l2_state
) -> epoch_rollup_inputs
```
This version of `get_epoch_rollup_inputs` should guarantee that all `epoch_deposits` will be included somewhere within `epoch_rollup_inputs`. The `epoch_sequence_data` can be computed by the batch submitter so that those deposits end up in `epoch_rollup_inputs` at the same position that the sequencer has chosen to include them as pending blocks, solving for both goals above.

## Rollup Epochs

The rollup chain is subdivided into epochs. There is a 1:1 correspondence between L1 block numbers and epoch numbers. For L1 block number `n`, there is a corresponding rollup epoch `n` which can only be generated after L1 block number `n` is added to the L1 chain. Epoch contain one to many rollup blocks.

### Types of Blocks within Epochs

Within these epochs, there are two block types:

1. Deposit block
2. Sequencer block

Deposit blocks contain contextual information about L1 such as the block hash. They also contain transactions initiated on L1 by any user or contract.

Sequencer blocks are submitted by the sequencer and target _future_ epochs which satisfy the following two conditions:

1. Target epoch is larger than the current L1 block number.
2. Target epoch is less than the current L1 block number PLUS `sequencing_window_size`.

The ability for the sequencer to append sequencer blocks to future epochs allows the sequencer to predict and influence the state of the epoch before the L1 chain has mined it. This property is what enables _fast transaction confirmations_ via the sequencer replicator.

### Epoch Structure

Each epoch contains **1** deposit block and zero to many sequencer blocks. For epoch `n` the deposit block is generated using L1 block number `n - (sequencing_window_size + 1)`. The epoch's sequencer blocks are contained in any of the L1 blocks ranging from `n - sequencing_window_size` to `n`. This a range of blocks is called the "sequencing window".

The following diagram demonstrates the correspondence between L1 blocks and rollup blocks (ie L2 blocks):

![Sequencer block generation diagram](../../assets/sequencer-block-gen.svg)

## Deposit Blocks in Depth

For every L1 block (after the rollup's genesis) an L2 deposit block is created. These deposit blocks contain both a `ContextDeposit` and any number of `UserDeposit`s. Context deposits set contextual information about the latest L1 block (eg. `blockHash` and `timestamp`), and user deposits are L1 user initiated L2 transactions which guarantee liveness of the rollup chain even with a censoring sequencer.

The types of deposit blocks are as follows:

```python
class DepositBlock:
    deposits: List[Deposit]

class Deposit:
    feedIndex: uint64
    GasLimit:  uint64

class UserDeposit(Deposit):
    isEOA:       bool
    l1TxOrigin:  Address
    target:      Address
    data:        bytes

class ContextDeposit(Deposit):
    blockHash:   bytes32
    blockNumber: uint64
    timestamp:   uint64
    baseFee:     uint64
```

### Deposit Block Generation

The function `generate_deposit_block(l1_block_number)` is defined as:

- Generate the `ContextDeposit` using the L1 block body. Specifically the L1 block's `blockHash`, `blockNumber`, `timestamp`, and `baseFee`.
- Get all events emitted by the `DepositFeed` contract at block `l1_block_number`.
    - For each event, generate a new `UserDeposit` based on the emitted calldata. All fields should be emitted by DepositFeed contract.

#### **Footnote**: The DepositFeed ensures that no matter the size of the event it is possible to prove the deposit data to the fraud proof. See the DepositFeed spec for details.

## Sequencer Blocks in Depth

Sequencer blocks contain a majority of the transactions submitted to the rollup chain. Sequencer blocks can also influence the current timestamp of L2 which is exposed to contracts & is used in the EIP1559 fee pricing calculations.

Sequencer blocks are of the following form:

```python
class SequencerBlock:
    target_epoch: uint64  # epoch number that this block is intended for
    sequencer_suggested_timestamp: uint64  # a timestamp suggested by the sequencer
    transactions: List[Transaction]  # A list of transactions in the block
```

These sequencer blocks must be validated as properly formatted. These validity checks are:

1. `target_epoch` must be within the sequencing window (introduced in the previous sections)
2. `sequencer_suggested_timestamp` must be monotonic & within an acceptable range.
3. `transactions` must all be correctly formatted (eg. contain valid signatures).

If any of these checks fail the block must be skipped or ignored. Otherwise, all transactions in the sequencer block will be executed.

## Timestamps in Depth

Time can be manipulated by the sequencer; however, it must stay within reasonable bounds and must be monotonic (ie. can never go backwards). The specific conditions that must be met are:

```python
# last_l1_timestamp is the L1 timestamp set during the last ContextDeposit
# last_timestamp is the timestamp from the previous rollup block
# average_l1_block_time is the average time between two L1 blocks
# sequencing_window_size is the number of L1 blocks the sequencer has to submit their blocks
min_timestamp = max(last_l1_timestamp, last_timestamp)
max_timestamp = last_l1_timestamp + sequencing_window_size * average_l1_block_time

assert sequencer_suggested_timestamp >= min_timestamp
assert sequencer_suggested_timestamp <= max_timestamp
```

The timestamp exposed on the rollup chain is:

```python
# last_sequencer_suggested_timestamp is the most recent valid sequencer_suggested_timestamp
def timestamp():
    max(last_l1_timestamp, last_sequencer_suggested_timestamp)
```


## Epoch Block Input Generation
An epoch's block inputs can be generated using the following function:

- To generate the blocks in epoch `n`, supply L1 blocks `n - (sequencing_window_size + 1)` through `n`. This function returns a list of all rollup blocks in epoch `n`. We will call this list `epoch_rollup_blocks`.
- The first block input for the epoch is always the deposit block.
    - Generate the block input with `generate_deposit_block(l1_blocks[0])` (function defined above).
    - Append the deposit block to `epoch_rollup_blocks`
- To generate all of the sequencer blocks, for each block in `l1_blocks`:
    - Extract the valid sequencer blocks
    - If they are targeting epoch `n`, append the sequencer block to `epoch_rollup_blocks`.
- Return `epoch_rollup_blocks`.

After having generated each epoch it is possible to stich all epochs together to form the full rollup chain.

[exec-engine-diffs]: ./exec_engine.md#differences-between-l1-and-l2-ee
[rollup-driver]: ./rollup_driver.md